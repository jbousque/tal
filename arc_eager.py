# -*- coding: utf-8 -*-
"""Arc-eager.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X9n5ZK6VRttOXcYYC9TU2QJ2Gi35QFxh

## Colab
"""

### Pour utiliser sur google colab

import os

from google.colab import drive
drive.mount('drive')

!mkdir -p drive -v
#!google-drive-ocamlfuse drive

cwd = os.getcwd()

#### Changez le chemin ci-dessous vers votre repertoire dans votre googledrive
##############################################################################

monchemin = 'drive/My Drive/M2-IAAA/TAL/Projet/'

dir_path  = os.path.join(cwd, monchemin)
dirs = os.listdir(dir_path)
os.chdir(dir_path)

###

"""## Word"""

class Word:
    def __init__(self):
        self.featDic = {}

    def getFeat(self, featName):
        if(not featName in self.featDic):
            print('WARNING : feat', featName, 'does not exist')
            return None
        else:
            return self.featDic[featName]

    def setFeat(self, featName, featValue):
        self.featDic[featName] = featValue

    def affiche(self, mcd):
        for elt in mcd:
            feat, status = elt
            print(self.getFeat(feat), '\t', end='')
        print('')

        
    @staticmethod
    def fakeWord(mcd):
        w =Word()
        for elt in mcd:
            feat, status = elt
            w.setFeat(feat, 'ROOT')
        return w

    @staticmethod
    def invalidGov():
        return 123456789

    @staticmethod
    def invalidLabel():
        return ''

"""## WordBuffer"""

class WordBuffer:
        def __init__(self, mcd=None):
                self.currentIndex = 0
                self.array = []
                self.length = 0
                self.mcd = mcd
                
        def addWord(self, w):
                self.array.append(w)
                self.length += 1

        def affiche(self, mcd):
                for w in self.array:
                        w.affiche(mcd)

        def getLength(self):
                return self.length
        
        def getCurrentIndex(self):
                return self.currentIndex

        def getWord(self, index):
                return self.array[index]

        def getCurrentWord(self):
                return self.getWord(self.currentIndex)
            
        def nextSentence(self):
                sentence = []
                sentence.append(Word.fakeWord(self.mcd))
                if self.currentIndex == self.length - 1 :
                        return False
                while self.currentIndex < self.length :
                        sentence.append(self.getCurrentWord())
#                        self.getCurrentWord().affiche(self.mcd)
                        if int(self.getCurrentWord().getFeat('EOS')) == 1 :
                                self.currentIndex += 1
                                return sentence
                        else:
                                self.currentIndex += 1
                
        def readFromMcfFile(self, mcfFilename):
                try:
                        mcfFile = open(mcfFilename, encoding='utf-8')
                except IOError:
                        print(mcfFilename, " : ce fichier n'existe pas")
                        exit(1)
                tokens = []
                for ligne in mcfFile:
                        tokens = ligne.split()
                        w = Word()
                        for i in range(0, len(tokens)):
                                if(self.mcd[i][0] == 'GOV'):
                                        w.setFeat(self.mcd[i][0], tokens[i])
                                        w.setFeat('GOVABS', str(self.length + int(tokens[i]))) # compute absolute index of governor
                                else:
                                        w.setFeat(self.mcd[i][0], tokens[i])
                        self.addWord(w)
                mcfFile.close();
                
        def readFromConlluFile(self, conlluFilename):
                conlluFile = open(conlluFilename, encoding='utf-8')
                
                tokens = []
                for ligne in conlluFile:
#                        print(ligne)
                        if ligne[0] == '\n' :
                                self.getWord(self.currentIndex - 1).setFeat('EOS', '1')
                                next
                        elif ligne[0] == '#' :
#                                print("commentaire")
                                next
                        else :
#                                1	Je	il	PRON	_	Number=Sing|Person=1|PronType=Prs	2	nsubj	_	_
#featModel = (('B', 0, 'POS'),('S', 0, 'POS'), ('B', 0, 'GOV'), ('S', 0, 'GOV'), ('B', -1, 'POS'), ('B', 1, 'POS'))
                                tokens = ligne.split("\t")
                                if '-' not in tokens[0]:
                                        w = Word()
                                        for i in range(0, len(tokens)):
                                                if i == 0 :
                                                        w.setFeat('INDEX', tokens[i])
                                                if i == 1 :
                                                        w.setFeat('FORM', tokens[i])
                                                if i == 2 :
                                                        w.setFeat('LEMMA', tokens[i])
                                                if i == 3 :
                                                        w.setFeat('POS', tokens[i])
                                                if i == 4 :
                                                        w.setFeat('X1', tokens[i])
                                                if i == 5 :
                                                        w.setFeat('MORPHO', tokens[i])
                                                if i == 6 :
                                                        w.setFeat('GOV', tokens[i])
                                                if i == 7 :
                                                        w.setFeat('LABEL', tokens[i])
                                                if i == 8 :
                                                        w.setFeat('X2', tokens[i])
                                                if i == 9 :
                                                        w.setFeat('X3', tokens[i])
                                        w.setFeat('EOS', '0')
                                        self.addWord(w)
                conlluFile.close();
                
        def end(self):
                if(self.getCurrentIndex() >= self.getLength()):
                        return True
                else:
                        return False

"""## Dicos"""

class Dicos:
        def __init__(self, mcd=False, fileName=False, verbose=False):
                self.content = {}
                self.locked = False
                if mcd :
                        for elt in mcd :
                                name, status = elt;
                                if(status == 'SYM') : self.content[name] = ['NULL', 'ROOT']
                elif fileName :
                        try:
                                dicoFile = open(fileName, encoding='utf-8')
                        except IOError:
                                print(fileName, 'does not exist')
                                exit(1)
                        for ligne in dicoFile:
                                if ligne[0] == '#' and ligne[1] == '#' :
                                        currentDico = ligne[2:-1]
                                        self.content[currentDico] = []
                                        if(verbose): print('in module', __name__, 'create dico', currentDico)
                                else:
                                        value = ligne[:-1]
                                        if not value in self.content[currentDico] :
                                                self.content[currentDico].append(value)
                                                if(verbose): print('in module', __name__, 'adding entry', value, 'to', currentDico)
                        dicoFile.close()
                        self.lock()


        def populateFromMcfFile(self, mcfFilename, mcd, verbose=False):
                try:
                        mcfFile = open(mcfFilename, encoding='utf-8')
                except IOError:
                        print('cannot open', mcfFilename)
                        exit(1)
                        tokens = []
                for ligne in mcfFile:
                        tokens = ligne.split()
                        for i in range(0, len(tokens)):
                                if mcd[i][1] == 'SYM' :
                                        if not tokens[i] in self.content[mcd[i][0]] :
                                                self.content[mcd[i][0]].append(tokens[i])
                                                if(verbose): print('in module:', __name__, 'adding value ', tokens[i], 'to dico', mcd[i][0]) 
                mcfFile.close();
                for e in self.content:
                        print('DICO', e, ':\t', len(self.content[e]), 'entries')
                                                        
        def populateFromConlluFile(self, conlluFilename, verbose=False):
                mots_set = set()
                mots = []
                pdd_set = set()
                pdd = []
                try:
                        conlluFile = open(conlluFilename, encoding='utf-8')
                except IOError:
                        print('cannot open', conlluFilename)
                        exit(1)
                mcd = (('INDEX', 'INT'), ('FORM', 'INT'), ('LEMMA', 'INT'), ('POS', 'SYM'), ('X1', 'INT'), ('MORPHO', 'INT'), ('GOV', 'SYM'), ('LABEL', 'SYM'), ('X2', 'SYM'), ('X3', 'SYM'))
                tokens = []
                for ligne in conlluFile:
                        if ligne[0] != '\n' and ligne[0] != '#' :
                                tokens = ligne.split("\t")
                                for i in range(0, len(tokens)):

                                        if tokens[1] not in mots_set:  
                                          mots_set.add(tokens[1])
                                          mots.append(tokens[1])
                                        if tokens[3] not in pdd_set:  
                                          pdd_set.add(tokens[3])
                                          pdd.append(tokens[3])
                                          
                                        if mcd[i][1] == 'SYM' :
                                                if not tokens[i] in self.content[mcd[i][0]] :
                                                        self.content[mcd[i][0]].append(tokens[i])
                                                        if(verbose): print('in module:', __name__, 'adding value ', tokens[i], 'to dico', mcd[i][0]) 
                conlluFile.close();
                for e in self.content:
                        print('DICO', e, ':\t', len(self.content[e]), 'entries')
                return mots,pdd
                                                        
        def lock(self):
                self.locked = True
                for key in self.content.keys():
                        self.content[key] = tuple(self.content[key])

        def print(self):
                for dico in self.content.keys():
                        print(dico, self.content[dico])

        def printToFile(self, filename):
            try:
                dicoFile = open(filename, 'w', encoding='utf-8')
            except IOError:
                print('cannot open', filename)
                exit(1)
            for dico in self.content.keys():
                dicoFile.write('##')
                dicoFile.write(dico)
                dicoFile.write('\n')
                for elt in self.content[dico]:
                    dicoFile.write(elt)
                    dicoFile.write('\n')
            dicoFile.close()

        def getCode(self, dicoName, symbol, verbose=False) :
                if(verbose) : print('in module ', __name__, 'getCode(', dicoName, ',', symbol, ')')
                if not self.locked :
                        print('Dicos must be locked before they can be accessed')
                        return False
                if not dicoName in self.content :
                        print('no such dico as', dicoName)
                        return False
#                print('dicoName =', dicoName, 'symbol =', symbol)
                return self.content[dicoName].index(symbol)

        def getSymbol(self, dicoName, code) :
                if not self.locked :
                        print('Dicos must be locked before they can be accessed')
                        return False
                if not dicoName in self.content :
                        print('no such dico as', dicoName)
                        return False
                return self.content[dicoName][code]

        def add(self, dicoName, symbol) :
                if not dicoName in self.content :
                        self.content[dicoName] = {symbol}
                else:
                        self.content[dicoName].add(symbol)

"""## create_dicos"""

import sys

def getUniqueWords(allWords) :
    uniqueWords = [] 
    for i in allWords:
        if not i in uniqueWords:
            uniqueWords.append(i)
    return uniqueWords

if len(sys.argv) < 3 :
    print('usage:', sys.argv[0], 'conllu_file (input) dico_file (output)')
    exit(1)


mcd = (('INDEX', 'INT'), ('FORM', 'INT'), ('LEMMA', 'INT'), ('POS', 'SYM'), ('X1', 'INT'), ('MORPHO', 'INT'), ('GOV', 'SYM'), ('LABEL', 'SYM'), ('X2', 'SYM'), ('X3', 'SYM'))


print('populating dicos from file ', "UD_French-GSD/fr_gsd-ud-train.conllu")
dicos = Dicos(mcd)
mots,pdd = dicos.populateFromConlluFile("UD_French-GSD/fr_gsd-ud-train.conllu", verbose=False)
dicos.lock()
#print('saving dicos in file ', sys.argv[2])
#dicos.printToFile(sys.argv[2])

print(len(mots))
print(len(pdd))

print(mots[50])
print(mots.index("et"))

"""## read_conllu"""

import sys



mcd =(('INDEX', 'INT'), ('FORM', 'INT'), ('LEMMA', 'INT'), ('POS', 'SYM'), ('X1', 'INT'), ('MORPHO', 'INT'), ('GOV', 'SYM'), ('LABEL', 'SYM'), ('X2', 'SYM'), ('X3', 'SYM'))

wb = WordBuffer(mcd);
wb.readFromConlluFile("UD_French-GSD/fr_gsd-ud-train.conllu");

#wb.affiche(mcd)

def printSentence(sentence, mcd):
    for i in range(0, len(sentence)):
        sentence[i].affiche(mcd)


sentence = wb.nextSentence()
sentNb = 1
while sentence :
    print('sentence', sentNb)
    printSentence(sentence, mcd)
    sentNb += 1
    sentence = wb.nextSentence()

try:
  conlluFile = open("UD_French-GSD/fr_gsd-ud-train.conllu", encoding='utf-8')
except IOError:
  print('cannot open', conlluFilename)
  exit(1)

phrase = [] # 0 = mot , 1 = pdd , 2 = head , 3 = deprel


for ligne in conlluFile:
  if ligne[0] == '\n': break
  if ligne[0] != '\n' and ligne[0] != '#' :
    tokens = ligne.split("\t")
    #for i in range(0, len(tokens)):
    #print(tokens[6])
    phrase.append([tokens[1],tokens[3],tokens[6],tokens[7]])


print(phrase)



arcs = parser(phrase)

print([(i[0],j[0]) for (i,j) in arcs])

from random import randint
import numpy as np





def left_arc(stack,buffer,arcs,tab_head,index_phrase,needs):
  arcs.append((buffer[0],stack[len(stack)-1]))
  if ( stack[len(stack)-1]  in tab_head and str(index_phrase.index(stack[len(stack)-1][0]))  not in needs): # Si le dernier mot du stack a deja sont head
    stack.pop(len(stack)-1)
  else:
    word = buffer.pop(0) # Retire le premier mot du buffer 
    stack.append(word)
  return stack,buffer,arcs
  
def right_arc(stack,buffer,arcs,tab_head,index_phrase,needs):
  arcs.append((stack[len(stack)-1],buffer[0]))
  if ( buffer[0] in tab_head and str(index_phrase.index(buffer[0][0]))  not in needs): # Si le premier mot du buffer à deja sont head
    word = buffer.pop(0)
    stack.append(word)
  else :
     stack.pop(len(stack)-1)
  return stack,buffer,arcs
  
def shift(stack,buffer):
  word = buffer.pop(0)
  stack.append(word)
  return stack , buffer
  
def reduce(stack):
  stack.pop(len(stack)-1)
  return stack

def oracle(w1,w2,phrase,dist,tab_head,needs):

  if ( int(w1[2]) == phrase.index(w2[0]) ):
    if ( str(phrase.index(w2[0])) in needs ): 
      needs.pop(needs.index(str(phrase.index(w2[0]))))
    tab_head.append(w1)
    return "RIGHT_"+str(w1[3]),2,tab_head,needs
  
  elif ( int(w2[2]) == phrase.index(w1[0])):
    if ( str(phrase.index(w1[0])) in needs ):
      needs.pop(needs.index(str(phrase.index(w1[0]))))
    tab_head.append(w2)
    return "LEFT_"+str(w2[3]),1,tab_head,needs
  
  elif (w1 in tab_head and str(phrase.index(w1[0])) not in needs) : 
    return "REDUCE",4,tab_head,needs
  
  else : 
    return "SHIFT",3,tab_head,needs
  

def listing(sentence):
  res = []
  for i in range(len(sentence)):
    res.append(i + 1)
  return res

def print_result(res,sentence):
  sentence = ["root"] + sentence
  for i in range(len(res)):
    w1 , w2 = res[i]
    print(sentence[w1],' -> ', sentence[w2])
    
def get_need(phrase):
  need = []
  [need.append(i[2]) for i in phrase]
  return need
    
    
def parser(phrase):
  tab_head = []
  buffer = phrase
  needs = get_need(phrase)
  phrase = [["Root","Root",0,"Root"]] + phrase
  index_phrase = [i[0] for i in phrase]
  arcs = []
  stack = []
  stack.append(["Root","Root",0,"Root"]) ## root
  
  

  while ( (len(buffer) != 0) & (len(stack) != 0)):
    print()
    print("buffer : ", [i[0] for i in buffer])
    print("stack : ", [i[0] for i in stack])
    print(needs)
    
    if ( stack[len(stack)-1] == [0,0,0,0]):
      dist = 0 - phrase.index(buffer[0])
    else :
      dist = phrase.index(stack[len(stack)-1])-phrase.index(buffer[0])
    
    if dist > 7 : dist = 7
    if dist < -7 : dist = -7
 
    
    X = [stack[len(stack)-1][0],buffer[0][0],stack[len(stack)-1][1],buffer[0][1],dist]
    
    
    Y, gold,tab_head,needs = oracle(stack[len(stack)-1],buffer[0],index_phrase,dist,tab_head,needs)

    print(Y)
    
    if ( gold == 1 ):
      stack,buffer,arcs = left_arc(stack,buffer,arcs,tab_head,index_phrase,needs)
    elif (gold == 2):
      stack,buffer,arcs = right_arc(stack,buffer,arcs,tab_head,index_phrase,needs)
    elif (gold == 3):
      stack,buffer = shift(stack,buffer)
    elif (gold == 4):
      stack = reduce(stack)
      
  return arcs

"""Sortir X et Y 
Sortir liste de mot ( vocab )

mot1 = stack[0] 
mot2 = buffer[0]

X = [ mot1 , mot2 , pdd1 , pdd2, dist]
mot1 = vocab_mot[mot1]
pdd = vocab_pdd

Y = vocab_liaison

si dist > 7

voc_liaison[0 = shift , 1 = reduce , left_1,  right_1 , left_2 ...  ]
"""